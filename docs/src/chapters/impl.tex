\chapter{Fejlesztői dokumentáció}
\label{ch:impl}

Az alkalmazás a könnyű megközelíthetőség miatt web alapúan kerül megvalósításra. Ennek számos előnye van. Az alkalmazás nem igényel telepítést, bármilyen számítógépről, bármikor elérhető. A már ismert webes technológiákat alkalmazhatjuk. És Progresszív Web Alkalmazás (PWA \cite{PWA}) lévén az első megnyitást leszámítva aktív internetelérés sem kell a használatához.

\section{Megoldási terv}

Az alkalmazás fő eleme a projekt amit Lore-nak nevezünk, ennek an egy aznosítója mivel dokumentum szintű objektumról van szó, egy neve és ebben tároljuk a világ adatait melyek annak mérete és neve. Valamint ehhez a dokumentumhoz tartozik a világ textúrája is.

Egy projecthez tartoznak még szereplők amik szintén dokumentum szintű objektumok, saját kollekcióval. Ebben tároljuk a szereplő állapotait egy AVL fában \cite{AVL} amiben a kulcs az idő, ezzel biztosítva, hogy minden esemény időben sorban legyen, és gyorsan elérhetőek legyenek. Szükség lesz ehhez a fához néhány segédeljárásra, szerencsére ezen TypeScript implementációja az AVL fának az enyém így ezeket könnyedén hozzáadhatom. A fő motiváló ereje ennek a segédcsomagnak a létrehozására épp az volt, hogy az alapvető implementáció mellé egy gazdag API-t biztosítsak.

Egy állapotdelta csak az előző állapotdeltákhoz viszonyított különbséget tartja nyilván, kivéve a pozíciót, ami minden esetben kötelező. Ezeket a deltákat a szereplők és a jelenlegi idő csöveinek összevezetésével egy aggregátoreljárás értékeli ki. Erre feliratkozva bármi azonnal hozzáférhet a legfrissebb adatokhoz ami csak egy helyen, egyszer van emiatt kiszámolva.

\subsection{Az adatmodell}
\begin{plantuml}
@startuml
skinparam monochrome true

note left of Lore: Tartozhat minden példányhoz egy\nRxDocument 'texture' azonosítóval

interface Lore {
	id: string
	name: string
	planet: Planet
}

interface Planet {
	name: string
	radius: number
}

interface Actor {
	id: string
	loreId: string
	states: Tree
}

note left of Tree: Nem perzisztálható de szérializálható
class Tree {
	root: Node
}

class Node {
	key: number
	value: ActorDelta
}

note left of ActorDelta: Egy AVL\nfában helyezkednek el
interface ActorDelta {
	position: Vec3
	name?: string
	maxSpeed?: number
	color?: string
	properties?: Array<Property>
}

interface Vec3 {
	x: number
	y: number
	z: number
}

interface Property {
	key: string
	value: string
}

Lore -- Planet
Lore --o Actor
Actor -- Tree
Tree --* Node
Node -- ActorDelta

ActorDelta --* Property
ActorDelta -- Vec3

@enduml
\caption{Az adatmodell}
\label{fig:data-model}
\end{plantuml}
%	\caption{Az adatmodell}
%	\label{fig:data-model}
%\end{figure}

\subsection{A reaktív modell}

A klasszikus imperatív modell helyett az alkalmazás jelentős részében reaktív komponenseket használunk amik alapjául az RxJS \cite{RxJS} csomag szolgál. Ez azt jelenti, hogy klasszikus adattagok helyett, adatforrásokat, megfigyelhető objektumokat (Lásd Megfigyelő programtervezési minta \cite{ObserverPattern}), függvényhívások helyett pedig mellékhatásokat használunk.

Ez a minta lehetőséget ad arra, hogy bármilyen nézet a böngészőben ami felhasznál valamilyen adatot, azonnal frissüljön mikor a forrása megváltozik.

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		hide empty description
		[*] -> Observable : Új adat kerül a megfigyelhető objektumba
		Observable --> Pipes
		Pipes : A csövek formában és időben is \nmegváltoztathatják a bennük átfolyó adatot
		Pipes --> SideEffects : A transzformáció közben mellékhatásokat is definiálhatunk
		Pipes --> ObserversA
		Pipes --> ObserversB
		Pipes --> ObserversC : Majd pedig megérkeznek minden feliratkozóhoz

		SideEffects  --> [*]
		ObserversA --> [*]
		ObserversB --> [*]
		ObserversC --> [*] : És kifejtik hatásukat
		@enduml
	\end{plantuml}
	\caption{Adatfolyam a megfigyelő modellben}
	\label{fig:observer-pattern}
\end{figure}

Kétfajta adatot különböztetünk meg, perzisztens és temporális. Perzisztens adatnak minősül minden ami egy projekthez tartozik. Temporális meg az amiket az előbbi manipulálásakor használunk fel. Például projekthez tartozó adat az, hogy egy szereplőnk egy adott időpillanatban hol tartózkodik, de az nem, hogy a kurzor épp ezen az időpillanaton áll.

A perzisztens a böngészők beépített noSQL adatbázisában, az IndexedDB-ben kerülnek perzisztálásra, dokumentumok formájában. Az adatbázis elérésehez, és ezzel az alkalmazás reaktív modelljének alapkövének RxDB-t \cite{RxDB} használunk.

Ez a csomag lehetővé teszi, hogy adatok beszúrásakor/módosításakor/törlésekor ezek a folyamatok igéretekként (Lásd Promise \cite{Promise}) jelenjenek meg melyek teljesüléséről értesítést kapunk. Ezzel lehetővé téve olyan featureöket mint, hogy jelezni a felhasználónak, hogy egy adott elem adatainak forrása éppen mentés alatt áll, és a szerkesztését letiltani. A legfőbb előnye viszont az, hogy bármilyen adatbázis kollekciót, lekérdezést megfigyelhetünk. És amint változás történik az adatbázisban, ezek a megfigyelhető Query-k újra jeleznek, frissítve minden mást ami rájuk épül.

A temporális adatokat viszont felesleges adatbázisban tárolni csak azért, hogy reaktív módon kezelhessük őket. Lehetőség van minden ilyen adatnak egy saját forrást (Subject) biztosítani. De mi van ha két adat függ egymástól? Csöveken keresztül futtassuk őket össze, válasszuk szét majd az így keletkező csöveket használjuk ezentúl? Mi van ha erre a változtatásra később kerül sor? Mi van ha valamit elfelejtünk átállítani, hogy a direkt-forrás helyett a transzformált csövet használják? Ezek a problémák és még sok más megoldására jön képbe az NgRX \cite{NgRx} csomag és a Redux (\cite{Redux}) architektúra amit implementál.

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		hide empty description
		[*] -d-> View : Felhasználói interakció
		View -d-> Dispatcher : Akció
		Dispatcher -l-> Effects : Akció
		Effects -r-> Dispatcher : Akció
		Effects -l-> [*] : Mellékhatás

		Dispatcher --> Reducer : Akció
		CurrentState -> Reducer : Az előző állapot
		Reducer --> Store : Új állapot készül
		Store -u-> View : Értesít

		@enduml
	\end{plantuml}
	\caption{A Redux architektúra}
	\label{fig:redux-architecture}
\end{figure}

A lényeg a globális, nem módosítható (Csak cserélhető) állapot, az úgynevezett "igazság egyetlen forrása" ("Single source of truth") és az egyirányú adatfolyam (Unidirectional data-flow). Ennek hála egy átlátható, eseményeiben könnyen megjósolható programot kapunk, cserébe viszont sok kódot igényel.
Ezt egy központi Store service-ből tudjuk elérni, a könnyebb interakció miatt pedig egy Facade\cite{Facade} Service-t húzunk elé.

\section{Alkalmazás Architektúra}

Egy Angular alkalmazás modulokra van bontva. Minden modul saját Injection Scope-al rendelkezik, a felhasznált Service-ek pedig egyediek Injection Scope-onként. Mivel ez az alkalmazás csupán egy funkciót lát el megelégedhetnénk egy modullal is, de jobb felhasználói élményt érhetünk el ha az első töltést felgyorsítjuk azzal, hogy az applikációnk első töltési pontját kiürítjük, a tényleges applikációt pedig a gyökér routing pont mögé tesszük. Ez lusta módon \cite{LazyLoad} fogja betölteni a tényleges tartalommal rendelkező modult, nem blokkolva az alap modul tartalmának festését a DOM-ba. Az alap modul így taralmazhat egy egyszerű töltési animációt amit csak addig jelenítünk meg amíg a router tölti az almodult.

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true

		[-> AppModule: Applikáció indításakor
		activate AppModule
		AppModule -> AppModule : Első festés, LoreModule Lazy töltése

		activate  AppModule
		AppModule -> LoreModule
		deactivate AppModule

		activate LoreModule

		LoreModule ->]
		LoreModule <-]


		AppModule <- LoreModule: Kilépés
		deactivate LoreModule

		[<- AppModule: Kilépés
		deactivate AppModule

		@enduml


	\end{plantuml}
	\caption{Lusta betöltés}
	\label{fig:lazy-loading}
\end{figure}


\subsection{Komponensek}

Nézeteinket komponensekben definiáljuk, ezek az adataikat pedig kizárólag a StoreFacade-on keresztül kapják. Egyedül az Engine és a 3D színtér az ami közvetlen az adatbázissal kommunikál.

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true

		database IndexedDB {
			[LoreCollection]
			[ActorCollection]
		}

		database Store {
			[State]
		}

		IndexedDB -[hidden]--> LoreModule
		Store -[hidden]--> LoreModule

		IndexedDB .> (RxDB)


		package LoreModule {
			Store .> (StoreFacade)
			(RxDB) ..> (DatabaseService)
			(DatabaseService) .[hidden].> [Lore]
			(DatabaseService) <.> Engine
			Store <.. (DatabaseService)
			(StoreFacade) .> [Lore]
			(StoreFacade) .> Components
			(StoreFacade) .> Engine
			[Lore] <- Components
			node Components {

				node Control {
					[LightControl]
					[SceneControl]
					[PlayControl] --> [SpeedControl]
				}


				node Timeline {
					[Block] --> [Timeline]
					[Cursor] --> [Timeline]
				}
			}

			[Lore] <- Engine

			Engine -[hidden]-> Components

			node Engine {
				(EngineService)
				[EngineComponent]
			}


		}


		@enduml
	\end{plantuml}
	\caption{Főbb Komponensek és relációik}
	\label{fig:services-and-components}
\end{figure}

\subsection{Timeline}

Az idő az egész alkalmazásban epoch \cite{Epoch} formában van jelen, egy egyszerű számként, az egység a másodperc. Így könnyű egyszerű arithmetikai műveleteket végezni rajta.

Az idővonalat két időpont határoz meg, az eleje és a vége. A nézet szélességét figyelembe véve ezekből ki lehet számolni a vonalzó beosztásait. A beosztásokat napokban mérjük, az albeosztásokat pedig órában.

\subsubsection{Megjelenítés}

A beosztások mennyiségét és pozícióit ki kell számolnunk. Előbbit úgy kapjuk meg ha vesszük a megjelenített időablak hosszát és leosztjuk egy nappal ($86400s$). Az egészrésze lesz a kiférő beosztások száma. Viszont az albeosztások megjelenítésére is figyelnünk kell. Ezek fixen a tőle balra álló nagy beosztástól fognak elhelyezkedni. Ahhoz, hogy az idővonal legelején is lehessenek albeosztások -- az első látszódó beosztás előtt -- el kell tolnunk balra egy egységgel az idővonalat, és a végére még kettőt hozzáadni. Egy beosztás hosszát így kaphatjuk meg:

\begin{tabular}{@{}ll@{}}
	\textbf{Jel} & \textbf{Leírás} \\
	$a$ & Időablak kezdete \\
	$b$ & Időablak vége \\
	$d$ & A beosztás hossza ($86400$) \\
	$w$ & A komponens szélessége pixelben \\
	$d'$ & A beosztás szélessége pixelben \\
\end{tabular}
$$d' = \frac{w}{(b - a) / d}$$

A beosztások pozícióinak kiszámolásához, ahelyett, hogy minden beosztás helyét egyenként kiszámolnánk, csupán az első helyét számoljuk ki, a többit pedig ahhoz mérten, fix távolságban eltoljuk. Ezt azért tehetjük meg mert a beosztások egyenlő közönként vannak az idővonal egészén. Elég egyszer kiszámolni, hogy a $86400$ másodperc éppen mekkora távolságot jelent pixelben a képernyőn. Azután elég ennek a többszöröseit hozzáadni az első távolságához, minden egyes beosztásnál.

Az első távolság kiszámolásához viszont tudnunk kell, hogy melyik az a pont a kiválaszott időablakban ami egy napfordulót jelent:

$$ x \in \{[a, a+l] | x \% b = 0\} $$

Ehhez csak hozzá kell adni a beosztás hossza és a kezdeti érték maradékát a kezdeti értékhez miután kivontuk a beosztás hosszából:

$$x = a + (d - (a \% d))$$

Az albeosztásokat már tudjuk, hogy $24 - 1$ darab fog kelleni, kezdeti pozíciójuk meg nem számít, relatív a nagy beosztáshoz vannak elhelyezve. Csak azt kell kiszámolnunk, hogy az adott albeosztás másodpercben mennyit jelent ($0, 3600, 7200 \dots $) és pixelben mért távolsággá alakítani.


A két tartomány között lineárisan váltunk. A főbeosztások esetén a kezdeti tartomány az időablak, a céltartomány pedig a $[0, w]$ ahol $w$ a komponens szélessége. Az albeosztások esetén pedig $[0, 86400]$ ból váltunk $[0, d']$ be ahol $d'$ a beosztás hossza pixelben.

\begin{tabular}{@{}ll@{}}
	\textbf{Jel} & \textbf{Leírás} \\
	$x$ & A transzformálandó érték \\
	$a1$ & A forrás tartomány kezdete \\
	$a2$ & A forrás tartomány vége \\
	$b1$ & A cél tartomány kezdete \\
	$b2$ & A cél tartomány vége \\
\end{tabular}

$$ f(x) = b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 )$$

A beosztások mostmár helyesen helyezkedenek el minden időablak esetében.

\subsubsection{Manipulálás}

\paragraph{Folytonos manipuláláskor} mint például mikor pásztázunk az egerünkkel a kapott eseményben csak az eltolás mértékét kapjuk meg pixelben, ahhoz a pozícióhoz képest, ahol az elsolás kezdetekor az egér volt. A legtöbb ilyen esethez ezért definiálunk egy módszert amiben egy ilyen módon manipulálható adat mellé egy felülíró adattagot is definiálunk. Ez az adattag amikor nem történik esemény mindig \lstinline[columns=fixed]{undefined}.

Kiolvasni az adatpárost emiatt rövidzár kiértékeléssel egyszerű (\lstinline[columns=fixed]{override | original}). Fontos megjegyezni, hogy számok lévén, és mivel itt nem az adattag létezését vizsgáljuk hanem azt, hogy truthy e vagy sem, ha az \lstinline[columns=fixed]{override} értéke $0$ lenne, akkor ugyagyúgy az \lstinline[columns=fixed]{original} értékkel térne vissza a kifejezés. Mivel a $0$ az falsy. Így ezt csak akkor alkalmazzuk, ha tudjuk hogy ez az érték sosem lesz $0$. A másik megjegyzendő dolog, hogy miért nem egy osztályt definiálunk ennek a viselkedésnek a kezelésére. A válasz az, hogy ezek az adatok az állapot részét képezik, az állandó szérializálás és deszérializálás pedig túl sok extra komplexitást adna egy egyébként egyszerű feladathoz.

A folytonos manipuláció végén pedig az \lstinline[columns=fixed]{override} értékét beleírjuk az eredeti változóba majd kiürítjük.


A megjelenített időablakot kétféle módon manipulálhatjuk:

\begin{itemize}
	\item Eltolás (Translate)
	\item Merőleges affinitás (Scale)
\end{itemize}

\paragraph{Eltolásnál} csak egyenlő időmennyiséget vonunk ki vagy adunk hozzá az időablak mindkét végéhez

\paragraph{Affinitáshoz} pedig elég lenne ha nyújtásnál a kezdeti pontból kivonnánk, összenyomásnál pedig hozzáadnánk, a végpontból meg fordítva. Ezzel viszont mindig az időablak közepe lenne a sarkpontunk. A felhasználói élmény miatt ez a sarkpont mindig az egér pozíciója lesz. Szélsőséges esetekben, mikor az egész a komponens legelején helyezkedik el ez azt jeleti, hogy zoom-olásnál csak az időablak vége változik.

Ehhez a két vég módosítását súlyoznunk kell az egér pozíciója szerint. A pozíciót a böngésző belső ablakához relatív kapjuk meg, így a lineáris váltás kezdeti tartománya ${ta, ta + w}$ ahol $ta$ a timeline pozíciója horizontálisan, a céltartomány pedig $[0, 1]$. A kezeti pozíció súlya ez a szám lesz, a végéé pedig ehhez fordítottan arányos.

\subsubsection{A kurzor}

A kurzor egy időpontot jelöl. A színtérben, és a viewben minden aggregált adat ennek függvényében jelenik meg. Pozícióját hasonlóan az eddigikhez lineáris mappeléssel kapjuk meg. Manipulásakor pedig ugyanez történik visszafele.

\subsubsection{A blokkok}

Az idővonal sávjaiban a szereplő egy blokként jelenik meg. Egy blokknak -- hasonlóan az idővonalhoz -- van egy eleje és egy vége. Ezen belül pedig az események elemei helyezkednek el. A blokk eleje és vége mindig az első és az utolsó esemény ideje. Az események pozíciói a blokk elejének pozíciójához mérjük relatív.

Egy esemény idejének felülírásakor (Fogd-és-vidd ideje alatt) a gyakori változás miatt a fa-szerkezetet amiben az események vannak tárolva nem módosítjuk. Ehelyett egy felülírt esemény eseményt küldünk amiben leírjuk, hogy idő szerint melyik esemény hova került át. A színtér ezt az információt figyelembevéve módosítás közben is helyes adatokat tud kirajzolni.

\section{A színtér}

A 3D színtér komponensén két elem található: A canvas elem amire fest a Three.js és a buborékmenü ami a kijelölt szereplők felett helyezkedik el ha van ilyen. Erre a canvas elemre van felcsatolva az összes EventListener amivel interakcióba lehet lépni a színtérrel. Logikája annyiból áll, hogy ezeket az eseményekből kinyeri a hasznos információt, a pozíciót normalizálja a $[0-1]$ intervallumba, majd továbbítja az EngineService-nek ami aztán ezeket kezeli. Valamint megjelenítés után létrehozza a színtér modelljét és elindítja az animációs loopot.

\subsection{A színpad felépítése}

A színpad fő eleme a bolygó, egy fix $1$ sugarú gömb melyhez kapcsolódik egy másik, kisebb -- $0.98$ sugarú -- gömb ami a vízszintet reprezentálja. A gömb felszíne magas felbontású poligonok terén ($512×512$), hogy a displacement map \cite{Displacement} pontosabb eredeményt adjon.

Ekkora felbontásnál, az egy objektumon található rengeteg háromszög miatt a raycasting \cite{Raycast} rendkívül lassú a Three.js alap implementációjában. (Raycastingot akkor használunk amikor kiszámoljuk, hogy a színtér épp melyik objektumának melyik pontja felett áll az egér.) Szerencsére létezik gyorsabb eljárás. A Bounding Volume Hierarchy \cite{BVH} fa struktúrába helyezi az objektumok részeit elhelyezésük alapján, jelentősen lecsökkentve azokat a háromszögeket amiket a raycastingnak egyszerre meg kell vizsgálnia.

\begin{figure}[h!]
	\centering

	\begin{tikzpicture}[x=0.75pt,y=0.75pt,yscale=-1,xscale=1]
	%uncomment if require: \path (0,300); %set diagram left start at 0, and has height of 300

	%Shape: Circle [id:dp8728808526292304]
	\draw   (45.55,152) .. controls (45.55,99.27) and (88.3,56.52) .. (141.04,56.52) .. controls (193.77,56.52) and (236.52,99.27) .. (236.52,152) .. controls (236.52,204.73) and (193.77,247.48) .. (141.04,247.48) .. controls (88.3,247.48) and (45.55,204.73) .. (45.55,152) -- cycle ;
	%Shape: Circle [id:dp5674056113092418]
	\draw   (555,152) .. controls (555,138.47) and (565.97,127.5) .. (579.5,127.5) .. controls (593.03,127.5) and (604,138.47) .. (604,152) .. controls (604,165.53) and (593.03,176.5) .. (579.5,176.5) .. controls (565.97,176.5) and (555,165.53) .. (555,152) -- cycle ;
	%Shape: Axis 2D [id:dp667037457037013]
	\draw [line width=0.75]  (86.65,152) -- (630.5,152)(141.04,41.39) -- (141.04,164.29) (623.5,147) -- (630.5,152) -- (623.5,157) (136.04,48.39) -- (141.04,41.39) -- (146.04,48.39)  ;
	%Shape: Brace [id:dp5709274682232908]
	\draw   (141,152) .. controls (141,156.67) and (143.33,159) .. (148,159) -- (350.75,159) .. controls (357.42,159) and (360.75,161.33) .. (360.75,166) .. controls (360.75,161.33) and (364.08,159) .. (370.75,159)(367.75,159) -- (573.5,159) .. controls (578.17,159) and (580.5,156.67) .. (580.5,152) ;
	%Shape: Brace [id:dp38726825382608787]
	\draw   (237,151) .. controls (237,146.33) and (234.67,144) .. (230,144) -- (179.5,144) .. controls (172.83,144) and (169.5,141.67) .. (169.5,137) .. controls (169.5,141.67) and (166.17,144) .. (159.5,144)(162.5,144) -- (147.5,144) .. controls (142.83,144) and (140.5,146.33) .. (140.5,151) ;
	%Shape: Circle [id:dp559047975094662]
	\draw   (52.81,152) .. controls (52.81,103.28) and (92.31,63.78) .. (141.04,63.78) .. controls (189.76,63.78) and (229.26,103.28) .. (229.26,152) .. controls (229.26,200.72) and (189.76,240.22) .. (141.04,240.22) .. controls (92.31,240.22) and (52.81,200.72) .. (52.81,152) -- cycle ;
	%Shape: Brace [id:dp5585435570718464]
	\draw   (141,151) .. controls (141,146.33) and (138.67,144) .. (134,144) -- (121.5,144) .. controls (114.83,144) and (111.5,141.67) .. (111.5,137) .. controls (111.5,141.67) and (108.17,144) .. (101.5,144)(104.5,144) -- (60,144) .. controls (55.33,144) and (53,146.33) .. (53,151) ;
	%Left Arrow [id:dp007055379911458548]
	\draw   (415.67,45.1) -- (424.63,28.3) -- (426.94,33.9) -- (447.32,25.48) -- (451.94,36.67) -- (431.56,45.08) -- (433.87,50.68) -- cycle ;
	%Straight Lines [id:da28328227472011247]
	\draw  [dash pattern={on 4.5pt off 4.5pt}]  (141.04,152) -- (353.5,70) ;


	\draw   (235.08,-67.08) -- (416,45.34) -- (360.5,251) ;
	%Shape: Arc [id:dp11489271218380304]
	\draw  [draw opacity=0] (399.13,109.64) .. controls (379.34,104.55) and (362.14,90.46) .. (353.9,70.06) .. controls (345.66,49.66) and (348.24,27.59) .. (358.93,10.18) -- (415.67,45.1) -- cycle ; \draw   (399.13,109.64) .. controls (379.34,104.55) and (362.14,90.46) .. (353.9,70.06) .. controls (345.66,49.66) and (348.24,27.59) .. (358.93,10.18) ;
	%Shape: Circle [id:dp18625067716272725]
	\draw  [dash pattern={on 0.84pt off 2.51pt}] (31.79,152) .. controls (31.79,91.67) and (80.7,42.76) .. (141.04,42.76) .. controls (201.37,42.76) and (250.28,91.67) .. (250.28,152) .. controls (250.28,212.33) and (201.37,261.24) .. (141.04,261.24) .. controls (80.7,261.24) and (31.79,212.33) .. (31.79,152) -- cycle ;
	%Shape: Circle [id:dp21219909757761868]
	\draw  [dash pattern={on 0.84pt off 2.51pt}] (63.44,152) .. controls (63.44,109.15) and (98.18,74.41) .. (141.04,74.41) .. controls (183.89,74.41) and (218.63,109.15) .. (218.63,152) .. controls (218.63,194.85) and (183.89,229.59) .. (141.04,229.59) .. controls (98.18,229.59) and (63.44,194.85) .. (63.44,152) -- cycle ;
	%Shape: Brace [id:dp5998815658908982]
	\draw   (139.5,261) .. controls (143.62,261.27) and (145.82,259.35) .. (146.09,255.23) -- (146.09,255.23) .. controls (146.48,249.35) and (148.74,246.55) .. (152.85,246.82) .. controls (148.74,246.55) and (146.87,243.47) .. (147.26,237.59)(147.09,240.23) -- (147.26,237.59) .. controls (147.53,233.47) and (145.61,231.27) .. (141.5,231) ;

	% Text Node
	\draw (139,272) node  [align=left] {Globe};
	% Text Node
	\draw (579,204) node  [align=left] {Sun};
	% Text Node
	\draw (361,178) node  [align=left] {20};
	% Text Node
	\draw (169,126) node  [align=left] {1};
	% Text Node
	\draw (112,125) node  [align=left] {.98};
	% Text Node
	\draw (112,109) node  [align=left] {Water};
	% Text Node
	\draw (446.5,63) node  [align=left] {Camera};
	% Text Node
	\draw (377,61) node  [align=left] {120°};
	% Text Node
	\draw (279,245) node  [align=left] {Displacement Range};


	\end{tikzpicture}


	\caption{A színpad elemei}
	\label{fig:stage-structure}
\end{figure}

\subsubsection{A felszín}

A felszín displacement mapja egy memóriában található canvas objektum amit textúraként használunk. A jobb hatás érdekében ezt bumb-mapként \cite{Bump} is használjuk. Egy project betöltésekor és minden további módosításkor ez a textúra az adatbázisból újra betöltődik. Mivel a textúránk egy canvas objektumon létezik, könnyen elérhetjük egy canvas összes rajzfunkcióját, hogy egyszerűen, valós időben módosítsuk a térképet. A projekt szerkesztés menüjében lehetőségünk van bármikor betölteni bármilyen képet amit aztán ilyen textúraként fog használni az alkalmazás. Szerkesztésnél, minden, a bolygó felületén elhelyezkedő objektum megvizsgálja, hogy milyen magasan fog alatta a displacement megjelenni. Ehhez lehetne használni raycastingot, a kamera helyett az adott objektumból a gömb közepe felé vetítve, de sokkal egyszerűbb ha eleve a textúra fényességét vizsgáljuk meg, ugyanúgy ahogy azt a renderer is fogja tenni. Ezzel biztosítva van, hogy minden felszíni elem látszik akkor is ha a displacement alapból eltakarná.

\subsubsection{A szereplők}

A felszíni objektumok nagyrészt szereplőkből állnak. Ők szintén gömbök, saját emisszív felülettel, hogy a bolygó sötét oldalán is látszódjanak. Rendelkeznek még egy körvonallal is ha az egér felettük helyezkedik el, vagy ki vannak választva.

Elhelyezésüknél az egyszerű kezelés volt a fő szempont. Ezért a szereplők nem közvetlenül a bolygó objektumhoz vannak csatolva hanem egy -- szereplőnként egyedi -- csoporthoz vannak rendelve ami fixen a bolygó közepén helyezkedik el. Ez a csoport már a bolygóhoz van csatolva. Egy szereplő relatív pozíciója így mindíg $(0, 0, r + d)$ ahol $r = 1$, a bolygó felszínének sugara, $d$ pedig a displacement map magassága a szereplő objektum végleges helyén. Egy szereplőt elmozdítani így csak annyiba kerül, hogy a szülőjét -- a csoportot -- elforgatjuk.

Egy szereplő pontos pozíciójának meghatározásához a deltáit kell figyelembe vennünk. Az AVL fa implementáció amiben ezek el vannak helyezve rendelkezik olyan eljárással amivel nem fontos olyan kulcsot keresni ami tényleg létezik, mert a kulcshoz mindkét irányban legközelebb álló csomópontokkal fog visszatérni. Pontos egyezés esetén így mindkét csomópont ugyanaz lenne mint ha a hagyományos módon kértük volna le a kulcson található értéket.

A már meglévő csővezetékeink közzül a, szereplők, a jelenlegi idő és az esetlegesen felülírt pozíciók csövét összevezetjük a \lstinline[columns=fixed]{combineLatest} operátorral. Emiatt a pozíciókat kiszámoló eljárás mindig le fog futni, ha a három közzül bármelyik is megváltozik, a másik kettő utolsó eredményével. A felülírás csupán a jelenlegi idő alapján

Az eljárás minden szereplőre, aszinkron módon történik egyszerre. A cél kiszámolni minden színész csoportjának kvaternióit\cite{Quaternion}, hogy megfelelően legyenek elforgatva.

\begin{algorithm}[H]
	\caption{Pozícionálás}
	\label{alg:ibb}
	\textbf{\underline{Subscription}} pos($A, C, O$), ahol $A$ a szereplő. $C$ az idő. $O$ a felülírások listája.
	\begin{algorithmic}[1] % sorszámok megjelenítése minden n. sor előtt, most n = 1
	\STATE $e$ := $C$ körüli delták.

	\IF[Ha vannak felülírások]{$O$}
		\FOR[A színész összes deltájára]{$d : A$.deltas}
			\FOR{$o : O$}
				\IF[Ha ehhez tartozik]{$d.time = o.time$}
					\STATE $d.time$ := $d.newTime$
				\ENDIF
			\ENDFOR

			\IF{$d.time >= e[0].time \wedge d.time <= C$}
				\STATE $e[0]$ := $d$
			\ENDIF
			\IF{$d.time <= e[1].time \wedge d.time >= C$}
				\STATE $e[1]$ := $d$
			\ENDIF

		\ENDFOR
	\ENDIF

	\STATE $t$ := mapLinear($C$, $e[0]$.time, $e[1]$.time, 0, 1)
	\STATE $g$ := A színész objektumának csoportja a színtéren.  \COMMENT{ID alapján}
	\IF[Ha nem létezik, akkor itt létrehozzuk.]{!$g$}
		\STATE $g$ := Új színész objektumának csoportja
	\ENDIF
	\STATE $q0$ := $g$.lookAt($e[0]$.pos).q \COMMENT{Az első világpozícióhoz tartozó elforgatás}
	\STATE $q1$ := $g$.lookAt($e[1]$.pos).q \COMMENT{Az második világpozícióhoz tartozó elforgatás}
	\IF[Ha $t$ nem ugyanaz a két pont közé lett skálázva]{$t$}
		\STATE Compute $slerp(q0, q1, g.q, t)$ \COMMENT{Spherical Linear Interpolation}
	\ENDIF  \COMMENT{Honnan, hova, mit, mennyire}
	\STATE $A$.updateHeight() \COMMENT{Az eljárás során a cél $g.q$ megváltozása}
	\end{algorithmic}
\end{algorithm}





















































\subsection{Technológiák}

\begin{table}[H]
	\centering
	\begin{tabular}{ | m{0.20\textwidth} | m{0.80\textwidth} | }
		\hline
		\textbf{Csomag} & \textbf{Szerep} \\
		\hline \hline
		\emph{Angular} \cite{Angular} & A fő keretrendszer, biztosítja a build eszközöket mint Webpack. \\
		\hline
		\emph{RxDB} \cite{RxDB} & Reaktív interfészt biztosít a böngészők IndexedDB adatbázisaihoz. \\
		\hline
		\emph{NgRx} \cite{NgRx} & Reaktív állapot menedzsment. \\
		\hline
		\emph{Three.js} \cite{Three} & WebGL könyvtár a 3D grafikai elemekhez. \\
		\hline
		\emph{Tween.js} \cite{Tween} & Interpolációs könyvtár. \\
		\hline
		\emph{FontAwesome} \cite{FontAwesome} & Ikon könyvtár.  \\
		\hline
		\emph{TypeScript} \cite{TypeScript} & Típusos JavaScript kiegészítő.  \\
		\hline

		\emph{Sass} \cite{Sass} & CSS kiegészítő könyvtár.  \\
		\hline
	\end{tabular}
	\caption{Az alkalmazás technológiái}
	\label{tab:technologies}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{ | m{0.20\textwidth} | m{0.80\textwidth} | }
		\hline
		\textbf{Eszköz} & \textbf{Szerep} \\
		\hline \hline
		\emph{NPM} \cite{NPM} & JavaScript csomagkezelő eszköz.  \\
		\hline
		\emph{GitHub} \cite{Github} & Online git repository.  \\
		\hline
		\emph{Travis-CI} \cite{Travis} & Online build és deployment.  \\
		\hline
	\end{tabular}
	\caption{Devops eszközök}
	\label{tab:technologies}
\end{table}


-






A létrehozott projecteket egy Lore nevű dokumentum fogja tárolni




\section{Adat Modell}










Az alkalmazás induláskor az alábbi folyamat indul el, ez mindig biztosítani fog egy élő adatbáziselérést az applikáció többi részére.

\begin{plantuml}
	@startuml
	skinparam monochrome true
	[*] --> ApplicationBootstrap

	state ApplicationBootstrap {
		ApplicationBootstrap : Angular Inner Sequences
	}
	ApplicationBootstrap --> DatabaseBootstrap

	state DatabaseBootstrap {
		[*] --> InitializeCollections
		InitializeCollections : Lore
		InitializeCollections : Actor
		InitializeCollections : ActorDelta
		InitializeCollections --> InitializeExample
		InitializeExample : Az alap project létrehozása
		InitializeExample --> [*]
		note right of InitializeCollections : Ez a folyamat csak akkor\nhozza létre a kollekciókat\nha szükség van rá
	}

	DatabaseBootstrap --> DatabaseBootstrap : On Fail

	DatabaseBootstrap --> [*]

	@enduml
\end{plantuml}



\begin{plantuml}
	@startuml
	skinparam monochrome true
	DatabaseBootstrap --> LoresLoaded: LoadLores

	state LoresLoaded {
	}

	LoresLoaded --> LoreSelected: ChangeSelectedLore

	ChangeSelectedLore --> asd
	LoreSelected --> [*]


	@enduml
\end{plantuml}


\begin{plantuml}
	@startuml
	skinparam monochrome true
	[-> Database : Database Initialized
	== Initialization ==
	group LoadLores
		Database --> LoreState: Single find
	end
	== Repetition ==

	group State refresh hooks
		Database -> LoreState: On Insert
		Database -> LoreState: On Update
		Database -> LoreState: On Delete
	end

	group Database manipulation
		DatabasStateFacade -> Database: Do Insert
		DatabasStateFacade -> Database: Do Update
		DatabasStateFacade -> Database: Do Delete
	end

	LoreState --> LoreState: ChangeSelectedLore

	@enduml
\end{plantuml}

Az al-állapotokból kifele induló akciók mindíg a globális állapotteret jelentik, amik vissza fognak érkezni egy másik al-állapotba, vagy akár ugyanebbe.



\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		[-> Database : Database Initialized
		== Initialization ==

		Database --> LoreState: Load Lores
		LoreState -> LoreState: Shim each entry
		LoreState ->]: loadLoresSuccess
		@enduml
	\end{plantuml}
	\caption{A globális állapottér bootstrap folyamata}
	\label{fig:global-state-bootstrap}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		note left of LoreState : updateInitialSelectedLore
		[-> LoreState : loadLoresSuccess
		LoreState -> LoreState: Select the first one
		LoreState ->] : changeSelectedLore
		@enduml
	\end{plantuml}
	\caption{Az első kiválaszott project kiválasztása}
	\label{fig:global-state-bootstrap}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		Database --> LoreState: createLoreSuccess
		LoreState ->]: changeSelectedLore
		@enduml
	\end{plantuml}
	\caption{Új projekt létrehozásakor automatikusan kiválasztásra kerül}
	\label{fig:global-state-bootstrap}
\end{figure}


\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		[-> LoreState: changeSelectedLore
		LoreState ->]: changeSelectedLoreSuccess
		[-> ActorState: changeSelectedLoreSuccess
		Database --> ActorState: connection
		ActorState -> ActorState: loading everything into state
		ActorState ->]: loadActorsSuccess
		[-> ActorState: loadActorsSuccess
		loop for each actor object that has been loaded
		ActorState ->]: loadActorDeltasForActor
		end
		@enduml
	\end{plantuml}
	\caption{Projekt kiválasztásakor betöltődik az összes szereplő és azok összes deltái}
	\label{fig:global-state-bootstrap}
\end{figure}

\begin{figure}[h!]
	\centering
	\begin{plantuml}
		@startuml
		skinparam monochrome true
		[-> ActorDeltaState: loadActorDeltasForActor
		Database --> ActorDeltaState: connection
		ActorDeltaState -> ActorDeltaState: Shim every loaded object
		ActorDeltaState ->]: loadActorDeltasForActorSuccess
		@enduml
	\end{plantuml}
	\caption{Szereplő első betöltődésekor az összes deltáit is betöltjük}
	\label{fig:global-state-bootstrap}
\end{figure}

